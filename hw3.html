<!DOCTYPE html>
<html>
<head>
<style>
	#info {
		position: absolute;
		top: 0px;
		width: 100%;
		padding: 10px;
		text-align: center;
		color: #ffff00
	}
	body {
		overflow: hidden;
	}

</style>
</head>
<title>hw2</title>
<body>
<div id="info">HW2</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r70/three.min.js"></script>
<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>
<script>

var camera, scene, renderer;
var satellite, angle = 0;
var mousePoint;
var mouse = new THREE.Vector2();
//var stats;
var pos, vel, force;
var clock = new THREE.Clock();
var stArray = [];
var baseS = 0;
var counter = 0;
var keyboard = new KeyboardState();;
init();
animate();
function setUpStArray() {
	for (var i = 0; i < 3; i++) {
		var row = [];
		for (var j = 0; j < 6; j++)
			row.push(new THREE.Vector2(j * 0.2, 1 - 0.5 * i));
		stArray.push(row);
	}
}

function init() {
	renderer = new THREE.WebGLRenderer({
	antialias: true
});

	pos = new THREE.Vector3(0, 0, 0);
	vel = new THREE.Vector3(0, 0, 0);

	renderer.setSize(window.innerWidth, window.innerHeight);
	renderer.setClearColor(0x888888);
	document.body.appendChild(renderer.domElement);

	scene = new THREE.Scene();
	camera = new THREE.OrthographicCamera(-50, 50, 50, -50, -10, 100);
	camera.position.z = 10;
	scene.add(camera);


	var ground = new THREE.Mesh(new THREE.PlaneGeometry(100, 50), new THREE.MeshBasicMaterial({color: 0xff0000}));
	scene.add(ground);
	ground.position.y = -25;

	window.addEventListener('resize', onWindowResize, false);
	//  window.addEventListener('mousedown', onDocumentMouseDown, false);
	setUpStArray();

	// loading texture from imgur.com
	THREE.ImageUtils.crossOrigin = '';
	texture = THREE.ImageUtils.loadTexture('https://i.imgur.com/a1TiPHX.png');
	texture.wrapS = THREE.RepeatWrapping;

	// setting up texMat
	var texMat = new THREE.MeshBasicMaterial({
		map: texture,
		transparent: true,  // cutout texture: set transparent: true
		side: THREE.DoubleSide
	});

	var geometry = new THREE.Geometry();
	geometry.vertices.push(
		new THREE.Vector3(-15, -15, 0),
		new THREE.Vector3( 15, -15, 0),
		new THREE.Vector3( 15,  15, 0),
		new THREE.Vector3(-15,  15, 0)
	);

	var face;
	face = new THREE.Face3(0, 1, 2);
	geometry.faces.push(face);
	face = new THREE.Face3(0, 2, 3);
	geometry.faces.push(face);

	geometry.faceVertexUvs[0].push([stArray[1][0], stArray[1][1], stArray[0][1]]);
	geometry.faceVertexUvs[0].push([stArray[1][0], stArray[0][1], stArray[0][0]]);

	geometry.computeBoundingSphere();
	geometry.computeFaceNormals();
	geometry.computeVertexNormals();

	sprite = new THREE.Mesh(geometry, texMat);
	scene.add(sprite);
}

function onWindowResize() {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth, window.innerHeight);
}

function spriteAnimate() {
	var geometry = sprite.geometry;
	var st0 = stArray[1][baseS];
	var st1 = stArray[1][baseS + 1];
	var st2 = stArray[0][baseS + 1];
	var st3 = stArray[0][baseS];

	geometry.faceVertexUvs[0] = [];
	geometry.faceVertexUvs[0].push([st0, st1, st2]);
	geometry.faceVertexUvs[0].push([st0, st2, st3]);
	geometry.uvsNeedUpdate = true;

	baseS = (baseS + 1) % 5;
}

function animate() {
	keyboard.update();
	var dt = clock.getDelta();
	counter++;

	


	// force: add gravity first
	force = new THREE.Vector3(0, -90, 0);
	if (pos.y <= 1) {    // if contact, add contact force
		force.add(new THREE.Vector3(0, 90, 0));
	}  
/*	if ( keyboard.pressed("space") ){
		alert (pos.y);
		
	}*/
	if ( keyboard.pressed("left") && pos.y <= 1 ){
		vel.x = -20;	
	}

	if ( keyboard.up("left") && pos.y <= 1 ){
		vel.x = 0;
	}	
	
	if ( keyboard.pressed("right") && pos.y <= 1 ){
		if (counter % 4 === 0)
			spriteAnimate();
		vel.x = 20;
	}
	if ( keyboard.up("right") && pos.y <= 1 ){
		vel.x = 0;
	}
		
	if ( keyboard.pressed("up") && pos.y <= 1 ){
		vel.y = 100;
	}
	
	if( sprite.position.x >= 122 ){
		vel.x = -10;
	}
	if( sprite.position.x <= -122 ){
		vel.x = 10;
	}
	// move camera
	if(sprite.position.x - camera.position.x >= 30)
		camera.position.x += 0.3;
	if(camera.position.x - sprite.position.x >= 30)
		camera.position.x -= 0.3;
	// then do Euler's
	vel.add(force.clone().multiplyScalar(dt));
	pos.add(vel.clone().multiplyScalar(dt));
	sprite.position.copy(pos);


	if ( pos.y <= 0 ) {
		//pos.y = 0;
		vel.y *= -.8;
	} 
		        
	requestAnimationFrame(animate);
	render();
}

function render() {
	renderer.render(scene, camera);
}

</script>
</body>
</html>